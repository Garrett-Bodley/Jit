#! /usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'
require 'pathname'
require 'pry-nav'
require_relative '../lib/database/author'
require_relative '../lib/database/blob'
require_relative '../lib/database/commit'
require_relative '../lib/database/tree'
require_relative '../lib/database'
require_relative '../lib/entry'
require_relative '../lib/lockfile'
require_relative '../lib/refs'
require_relative '../lib/workspace'
require_relative '../lib/index'

command = ARGV.shift

case command
when 'init'
  path = ARGV.fetch(0, Dir.getwd)

  root_path = Pathname.new(File.expand_path(path))
  git_path = root_path.join('.git')

  ['objects', 'refs'].each do |dir|
    begin
      FileUtils.mkdir_p(git_path.join(dir))
    rescue Errno::EACCES => error
      $stderr.puts "Fatal: #{ error.message }"
      exit 1
    end
  end

  puts "Initialized empty Jit repository in #{ git_path }"
  exit 0

when 'add'
  root_path = Pathname.new(Dir.getwd)
  git_path = root_path.join('.git')
  db_path = git_path.join('objects')
  index_path = git_path.join('index')

  workspace = Workspace.new(root_path)
  database = Database.new(db_path)
  index = Index.new(index_path)

  index.load_for_update

  begin
    paths = ARGV.flat_map do |arg_path|
      path = Pathname.new(File.expand_path(arg_path))
      workspace.list_files(path)
    end
  rescue Workspace::MissingFile => error
    $stderr.puts "fatal: #{ error.message }"
    index.release_lock
    exit 128
  end

  begin
    paths.each do |path|
      data = workspace.read_file(path)
      stat = workspace.stat_file(path)

      blob = Database::Blob.new(data)
      database.store(blob)
      index.add(path, blob.oid, stat)
    end
  rescue Workspace::NoPermission => error
    $stderr.puts "error: #{ error.message }"
    $stderr.puts 'fatal: adding files failed'
    index.release_lock
    exit 128
  end

  index.write_updates
  exit 0

when 'commit'
  root_path = Pathname.new(Dir.getwd)
  git_path = root_path.join('.git')

  database = Database.new(git_path.join('objects'))
  index = Index.new(git_path.join('index'))
  refs = Refs.new(git_path)

  index.load

  root = Database::Tree.build(index.each_entry)
  root.traverse { |tree| database.store(tree) }

  root = Database::Tree.build(index.each_entry)
  root.traverse { |tree| database.store(tree) }

  parent = refs.read_head
  name = ENV.fetch('GIT_AUTHOR_NAME')
  email = ENV.fetch('GIT_AUTHOR_EMAIL')
  author = Database::Author.new(name, email, Time.now)
  message = $stdin.read

  commit = Database::Commit.new(parent, root.oid, author, message)
  database.store(commit)
  refs.update_head(commit.oid)

  File.open(git_path.join('HEAD'), File::WRONLY | File::CREAT) do |file|
    file.puts(commit.oid)
  end

  is_root = parent.nil? ? '(root-commit) ' : ''

  puts "[#{ is_root }#{ commit.oid }] #{ message.lines.first }"
  exit 0

else
  $stderr.puts "jit: '#{ command }' is not a jit command."
  exit 1
end
